/**
 * This file was auto-generated by `client-gen`.
 * Do not make direct changes to the file.
 */
import { GraphQLClient } from "graphql-request";
/**
 * @hidden
 */
export type QueryTree = {
    operation: string;
    args?: Record<string, unknown>;
};
/**
 * @hidden
 */
export type Metadata = {
    [key: string]: {
        is_enum?: boolean;
    };
};
interface ClientConfig {
    queryTree?: QueryTree[];
    host?: string;
    sessionToken?: string;
}
declare class BaseClient {
    protected _queryTree: QueryTree[];
    protected client: GraphQLClient;
    /**
     * @defaultValue `127.0.0.1:8080`
     */
    clientHost: string;
    sessionToken: string;
    /**
     * @hidden
     */
    constructor({ queryTree, host, sessionToken }?: ClientConfig);
    /**
     * @hidden
     */
    get queryTree(): QueryTree[];
}
export type BuildArg = {
    /**
     * The build argument name.
     */
    name: string;
    /**
     * The build argument value.
     */
    value: string;
};
/**
 * Sharing mode of the cache volume.
 */
export declare enum CacheSharingMode {
    /**
     * Shares the cache volume amongst many build pipelines,
     * but will serialize the writes
     */
    Locked = "LOCKED",
    /**
     * Keeps a cache volume for a single build pipeline
     */
    Private = "PRIVATE",
    /**
     * Shares the cache volume amongst many build pipelines
     */
    Shared = "SHARED"
}
/**
 * A global cache volume identifier.
 */
export type CacheVolumeID = string & {
    __CacheVolumeID: never;
};
export type ContainerAsTarballOpts = {
    /**
     * Identifiers for other platform specific containers.
     * Used for multi-platform image.
     */
    platformVariants?: Container[];
    /**
     * Force each layer of the image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     */
    forcedCompression?: ImageLayerCompression;
    /**
     * Use the specified media types for the image's layers. Defaults to OCI, which
     * is largely compatible with most recent container runtimes, but Docker may be needed
     * for older runtimes without OCI support.
     */
    mediaTypes?: ImageMediaTypes;
};
export type ContainerBuildOpts = {
    /**
     * Path to the Dockerfile to use.
     *
     * Default: './Dockerfile'.
     */
    dockerfile?: string;
    /**
     * Additional build arguments.
     */
    buildArgs?: BuildArg[];
    /**
     * Target build stage to build.
     */
    target?: string;
    /**
     * Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name] in the build container
     *
     * They can be accessed in the Dockerfile using the "secret" mount type
     * and mount path /run/secrets/[secret-name]
     * e.g. RUN --mount=type=secret,id=my-secret curl url?token=$(cat /run/secrets/my-secret)"
     */
    secrets?: Secret[];
};
export type ContainerExportOpts = {
    /**
     * Identifiers for other platform specific containers.
     * Used for multi-platform image.
     */
    platformVariants?: Container[];
    /**
     * Force each layer of the exported image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     */
    forcedCompression?: ImageLayerCompression;
    /**
     * Use the specified media types for the exported image's layers. Defaults to OCI, which
     * is largely compatible with most recent container runtimes, but Docker may be needed
     * for older runtimes without OCI support.
     */
    mediaTypes?: ImageMediaTypes;
};
export type ContainerImportOpts = {
    /**
     * Identifies the tag to import from the archive, if the archive bundles
     * multiple tags.
     */
    tag?: string;
};
export type ContainerPipelineOpts = {
    /**
     * Pipeline description.
     */
    description?: string;
    /**
     * Pipeline labels.
     */
    labels?: PipelineLabel[];
};
export type ContainerPublishOpts = {
    /**
     * Identifiers for other platform specific containers.
     * Used for multi-platform image.
     */
    platformVariants?: Container[];
    /**
     * Force each layer of the published image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     */
    forcedCompression?: ImageLayerCompression;
    /**
     * Use the specified media types for the published image's layers. Defaults to OCI, which
     * is largely compatible with most recent registries, but Docker may be needed for older
     * registries without OCI support.
     */
    mediaTypes?: ImageMediaTypes;
};
export type ContainerWithDefaultArgsOpts = {
    /**
     * Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
     */
    args?: string[];
};
export type ContainerWithDirectoryOpts = {
    /**
     * Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
     */
    exclude?: string[];
    /**
     * Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
     */
    include?: string[];
    /**
     * A user:group to set for the directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithEnvVariableOpts = {
    /**
     * Replace ${VAR} or $VAR in the value according to the current environment
     * variables defined in the container (e.g., "/opt/bin:$PATH").
     */
    expand?: boolean;
};
export type ContainerWithExecOpts = {
    /**
     * If the container has an entrypoint, ignore it for args rather than using it to wrap them.
     */
    skipEntrypoint?: boolean;
    /**
     * Content to write to the command's standard input before closing (e.g., "Hello world").
     */
    stdin?: string;
    /**
     * Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
     */
    redirectStdout?: string;
    /**
     * Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
     */
    redirectStderr?: string;
    /**
     * Provides dagger access to the executed command.
     *
     * Do not use this option unless you trust the command being executed.
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
     */
    experimentalPrivilegedNesting?: boolean;
    /**
     * Execute the command with all root capabilities. This is similar to running a command
     * with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
     * does not provide any security guarantees when using this option. It should only be used
     * when absolutely necessary and only with trusted commands.
     */
    insecureRootCapabilities?: boolean;
};
export type ContainerWithExposedPortOpts = {
    /**
     * Transport layer network protocol
     */
    protocol?: NetworkProtocol;
    /**
     * Optional port description
     */
    description?: string;
};
export type ContainerWithFileOpts = {
    /**
     * Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    permissions?: number;
    /**
     * A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithMountedCacheOpts = {
    /**
     * Identifier of the directory to use as the cache volume's root.
     */
    source?: Directory;
    /**
     * Sharing mode of the cache volume.
     */
    sharing?: CacheSharingMode;
    /**
     * A user:group to set for the mounted cache directory.
     *
     * Note that this changes the ownership of the specified mount along with the
     * initial filesystem provided by source (if any). It does not have any effect
     * if/when the cache has already been created.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithMountedDirectoryOpts = {
    /**
     * A user:group to set for the mounted directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithMountedFileOpts = {
    /**
     * A user or user:group to set for the mounted file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithMountedSecretOpts = {
    /**
     * A user:group to set for the mounted secret.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
    /**
     * Permission given to the mounted secret (e.g., 0600).
     * This option requires an owner to be set to be active.
     *
     * Default: 0400.
     */
    mode?: number;
};
export type ContainerWithNewFileOpts = {
    /**
     * Content of the file to write (e.g., "Hello world!").
     */
    contents?: string;
    /**
     * Permission given to the written file (e.g., 0600).
     *
     * Default: 0644.
     */
    permissions?: number;
    /**
     * A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithUnixSocketOpts = {
    /**
     * A user:group to set for the mounted socket.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    owner?: string;
};
export type ContainerWithoutExposedPortOpts = {
    /**
     * Port protocol to unexpose
     */
    protocol?: NetworkProtocol;
};
/**
 * A unique container identifier. Null designates an empty container (scratch).
 */
export type ContainerID = string & {
    __ContainerID: never;
};
/**
 * The `DateTime` scalar type represents a DateTime. The DateTime is serialized as an RFC 3339 quoted string
 */
export type DateTime = string & {
    __DateTime: never;
};
export type DirectoryAsModuleOpts = {
    /**
     * An optional subpath of the directory which contains the module's source
     * code.
     *
     * This is needed when the module code is in a subdirectory but requires
     * parent directories to be loaded in order to execute. For example, the
     * module source code may need a go.mod, project.toml, package.json, etc. file
     * from a parent directory.
     *
     * If not set, the module source code is loaded from the root of the
     * directory.
     */
    sourceSubpath?: string;
};
export type DirectoryDockerBuildOpts = {
    /**
     * Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
     *
     * Defaults: './Dockerfile'.
     */
    dockerfile?: string;
    /**
     * The platform to build.
     */
    platform?: Platform;
    /**
     * Build arguments to use in the build.
     */
    buildArgs?: BuildArg[];
    /**
     * Target build stage to build.
     */
    target?: string;
    /**
     * Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name].
     */
    secrets?: Secret[];
};
export type DirectoryEntriesOpts = {
    /**
     * Location of the directory to look at (e.g., "/src").
     */
    path?: string;
};
export type DirectoryPipelineOpts = {
    /**
     * Pipeline description.
     */
    description?: string;
    /**
     * Pipeline labels.
     */
    labels?: PipelineLabel[];
};
export type DirectoryWithDirectoryOpts = {
    /**
     * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     */
    exclude?: string[];
    /**
     * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    include?: string[];
};
export type DirectoryWithFileOpts = {
    /**
     * Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    permissions?: number;
};
export type DirectoryWithNewDirectoryOpts = {
    /**
     * Permission granted to the created directory (e.g., 0777).
     *
     * Default: 0755.
     */
    permissions?: number;
};
export type DirectoryWithNewFileOpts = {
    /**
     * Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    permissions?: number;
};
/**
 * A content-addressed directory identifier.
 */
export type DirectoryID = string & {
    __DirectoryID: never;
};
export type FileExportOpts = {
    /**
     * If allowParentDirPath is true, the path argument can be a directory path, in which case
     * the file will be created in that directory.
     */
    allowParentDirPath?: boolean;
};
/**
 * A file identifier.
 */
export type FileID = string & {
    __FileID: never;
};
export type FunctionWithArgOpts = {
    /**
     * A doc string for the argument, if any
     */
    description?: string;
    /**
     * A default value to use for this argument if not explicitly set by the caller, if any
     */
    defaultValue?: JSON;
};
/**
 * A reference to a FunctionArg.
 */
export type FunctionArgID = string & {
    __FunctionArgID: never;
};
/**
 * A reference to a Function.
 */
export type FunctionID = string & {
    __FunctionID: never;
};
/**
 * A reference to GeneratedCode.
 */
export type GeneratedCodeID = string & {
    __GeneratedCodeID: never;
};
export type GitRefTreeOpts = {
    sshKnownHosts?: string;
    sshAuthSocket?: Socket;
};
export type HostDirectoryOpts = {
    /**
     * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     */
    exclude?: string[];
    /**
     * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    include?: string[];
};
export type HostServiceOpts = {
    /**
     * Upstream host to forward traffic to.
     */
    host?: string;
};
export type HostTunnelOpts = {
    /**
     * Map each service port to the same port on the host, as if the service were
     * running natively.
     *
     * Note: enabling may result in port conflicts.
     */
    native?: boolean;
    /**
     * Configure explicit port forwarding rules for the tunnel.
     *
     * If a port's frontend is unspecified or 0, a random port will be chosen by
     * the host.
     *
     * If no ports are given, all of the service's ports are forwarded. If native
     * is true, each port maps to the same port on the host. If native is false,
     * each port maps to a random port chosen by the host.
     *
     * If ports are given and native is true, the ports are additive.
     */
    ports?: PortForward[];
};
/**
 * The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
 */
export type ID = string & {
    __ID: never;
};
/**
 * Compression algorithm to use for image layers.
 */
export declare enum ImageLayerCompression {
    Estargz = "EStarGZ",
    Gzip = "Gzip",
    Uncompressed = "Uncompressed",
    Zstd = "Zstd"
}
/**
 * Mediatypes to use in published or exported image metadata.
 */
export declare enum ImageMediaTypes {
    Dockermediatypes = "DockerMediaTypes",
    Ocimediatypes = "OCIMediaTypes"
}
/**
 * An arbitrary JSON-encoded value.
 */
export type JSON = string & {
    __JSON: never;
};
/**
 * A reference to a Module.
 */
export type ModuleID = string & {
    __ModuleID: never;
};
/**
 * Transport layer network protocol associated to a port.
 */
export declare enum NetworkProtocol {
    /**
     * TCP (Transmission Control Protocol)
     */
    Tcp = "TCP",
    /**
     * UDP (User Datagram Protocol)
     */
    Udp = "UDP"
}
export type PipelineLabel = {
    /**
     * Label name.
     */
    name: string;
    /**
     * Label value.
     */
    value: string;
};
/**
 * The platform config OS and architecture in a Container.
 *
 * The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
 */
export type Platform = string & {
    __Platform: never;
};
export type PortForward = {
    /**
     * Destination port for traffic.
     */
    backend: number;
    /**
     * Port to expose to clients. If unspecified, a default will be chosen.
     */
    frontend?: number;
    /**
     * Protocol to use for traffic.
     */
    protocol?: NetworkProtocol;
};
export type ClientContainerOpts = {
    id?: ContainerID;
    platform?: Platform;
};
export type ClientDirectoryOpts = {
    id?: DirectoryID;
};
export type ClientGitOpts = {
    /**
     * Set to true to keep .git directory.
     */
    keepGitDir?: boolean;
    /**
     * Set SSH known hosts
     */
    sshKnownHosts?: string;
    /**
     * Set SSH auth socket
     */
    sshAuthSocket?: Socket;
    /**
     * A service which must be started before the repo is fetched.
     */
    experimentalServiceHost?: Service;
};
export type ClientHttpOpts = {
    /**
     * A service which must be started before the URL is fetched.
     */
    experimentalServiceHost?: Service;
};
export type ClientModuleConfigOpts = {
    subpath?: string;
};
export type ClientPipelineOpts = {
    /**
     * Pipeline description.
     */
    description?: string;
    /**
     * Pipeline labels.
     */
    labels?: PipelineLabel[];
};
export type ClientSocketOpts = {
    id?: SocketID;
};
/**
 * A unique identifier for a secret.
 */
export type SecretID = string & {
    __SecretID: never;
};
export type ServiceEndpointOpts = {
    /**
     * The exposed port number for the endpoint
     */
    port?: number;
    /**
     * Return a URL with the given scheme, eg. http for http://
     */
    scheme?: string;
};
/**
 * A unique service identifier.
 */
export type ServiceID = string & {
    __ServiceID: never;
};
/**
 * A content-addressed socket identifier.
 */
export type SocketID = string & {
    __SocketID: never;
};
export type TypeDefWithFieldOpts = {
    /**
     * A doc string for the field, if any
     */
    description?: string;
};
export type TypeDefWithObjectOpts = {
    description?: string;
};
/**
 * A reference to a TypeDef.
 */
export type TypeDefID = string & {
    __TypeDefID: never;
};
/**
 * Distinguishes the different kinds of TypeDefs.
 */
export declare enum TypeDefKind {
    /**
     * A boolean value
     */
    Booleankind = "BooleanKind",
    /**
     * An integer value
     */
    Integerkind = "IntegerKind",
    /**
     * A list of values all having the same type.
     *
     * Always paired with a ListTypeDef.
     */
    Listkind = "ListKind",
    /**
     * A named type defined in the GraphQL schema, with fields and functions.
     *
     * Always paired with an ObjectTypeDef.
     */
    Objectkind = "ObjectKind",
    /**
     * A string value
     */
    Stringkind = "StringKind",
    /**
     * A special kind used to signify that no value is returned.
     *
     * This is used for functions that have no return value. The outer TypeDef
     * specifying this Kind is always Optional, as the Void is never actually
     * represented.
     */
    Voidkind = "VoidKind"
}
/**
 * The absense of a value.
 *
 * A Null Void is used as a placeholder for resolvers that do not return anything.
 */
export type Void = string & {
    __Void: never;
};
export type __TypeEnumValuesOpts = {
    includeDeprecated?: boolean;
};
export type __TypeFieldsOpts = {
    includeDeprecated?: boolean;
};
/**
 * A directory whose contents persist across runs.
 */
export declare class CacheVolume extends BaseClient {
    private readonly _id?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: CacheVolumeID);
    id(): Promise<CacheVolumeID>;
}
/**
 * An OCI-compatible container, also known as a docker container.
 */
export declare class Container extends BaseClient {
    private readonly _id?;
    private readonly _envVariable?;
    private readonly _export?;
    private readonly _imageRef?;
    private readonly _label?;
    private readonly _platform?;
    private readonly _publish?;
    private readonly _shellEndpoint?;
    private readonly _stderr?;
    private readonly _stdout?;
    private readonly _sync?;
    private readonly _user?;
    private readonly _workdir?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: ContainerID, _envVariable?: string, _export?: boolean, _imageRef?: string, _label?: string, _platform?: Platform, _publish?: string, _shellEndpoint?: string, _stderr?: string, _stdout?: string, _sync?: ContainerID, _user?: string, _workdir?: string);
    /**
     * A unique identifier for this container.
     */
    id(): Promise<ContainerID>;
    /**
     * Turn the container into a Service.
     *
     * Be sure to set any exposed ports before this conversion.
     */
    asService(): Service;
    /**
     * Returns a File representing the container serialized to a tarball.
     * @param opts.platformVariants Identifiers for other platform specific containers.
     * Used for multi-platform image.
     * @param opts.forcedCompression Force each layer of the image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     * @param opts.mediaTypes Use the specified media types for the image's layers. Defaults to OCI, which
     * is largely compatible with most recent container runtimes, but Docker may be needed
     * for older runtimes without OCI support.
     */
    asTarball(opts?: ContainerAsTarballOpts): File;
    /**
     * Initializes this container from a Dockerfile build.
     * @param context Directory context used by the Dockerfile.
     * @param opts.dockerfile Path to the Dockerfile to use.
     *
     * Default: './Dockerfile'.
     * @param opts.buildArgs Additional build arguments.
     * @param opts.target Target build stage to build.
     * @param opts.secrets Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name] in the build container
     *
     * They can be accessed in the Dockerfile using the "secret" mount type
     * and mount path /run/secrets/[secret-name]
     * e.g. RUN --mount=type=secret,id=my-secret curl url?token=$(cat /run/secrets/my-secret)"
     */
    build(context: Directory, opts?: ContainerBuildOpts): Container;
    /**
     * Retrieves default arguments for future commands.
     */
    defaultArgs(): Promise<string[]>;
    /**
     * Retrieves a directory at the given path.
     *
     * Mounts are included.
     * @param path The path of the directory to retrieve (e.g., "./src").
     */
    directory(path: string): Directory;
    /**
     * Retrieves entrypoint to be prepended to the arguments of all commands.
     */
    entrypoint(): Promise<string[]>;
    /**
     * Retrieves the value of the specified environment variable.
     * @param name The name of the environment variable to retrieve (e.g., "PATH").
     */
    envVariable(name: string): Promise<string>;
    /**
     * Retrieves the list of environment variables passed to commands.
     */
    envVariables(): Promise<EnvVariable[]>;
    /**
     * EXPERIMENTAL API! Subject to change/removal at any time.
     *
     * experimentalWithAllGPUs configures all available GPUs on the host to be accessible to this container.
     * This currently works for Nvidia devices only.
     */
    experimentalWithAllGPUs(): Container;
    /**
     * EXPERIMENTAL API! Subject to change/removal at any time.
     *
     * experimentalWithGPU configures the provided list of devices to be accesible to this container.
     * This currently works for Nvidia devices only.
     */
    experimentalWithGPU(devices: string[]): Container;
    /**
     * Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.
     *
     * Return true on success.
     * It can also publishes platform variants.
     * @param path Host's destination path (e.g., "./tarball").
     * Path can be relative to the engine's workdir or absolute.
     * @param opts.platformVariants Identifiers for other platform specific containers.
     * Used for multi-platform image.
     * @param opts.forcedCompression Force each layer of the exported image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     * @param opts.mediaTypes Use the specified media types for the exported image's layers. Defaults to OCI, which
     * is largely compatible with most recent container runtimes, but Docker may be needed
     * for older runtimes without OCI support.
     */
    export(path: string, opts?: ContainerExportOpts): Promise<boolean>;
    /**
     * Retrieves the list of exposed ports.
     *
     * This includes ports already exposed by the image, even if not
     * explicitly added with dagger.
     */
    exposedPorts(): Promise<Port[]>;
    /**
     * Retrieves a file at the given path.
     *
     * Mounts are included.
     * @param path The path of the file to retrieve (e.g., "./README.md").
     */
    file(path: string): File;
    /**
     * Initializes this container from a pulled base image.
     * @param address Image's address from its registry.
     *
     * Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
     */
    from(address: string): Container;
    /**
     * The unique image reference which can only be retrieved immediately after the 'Container.From' call.
     */
    imageRef(): Promise<string>;
    /**
     * Reads the container from an OCI tarball.
     *
     * NOTE: this involves unpacking the tarball to an OCI store on the host at
     * $XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.
     * @param source File to read the container from.
     * @param opts.tag Identifies the tag to import from the archive, if the archive bundles
     * multiple tags.
     */
    import_(source: File, opts?: ContainerImportOpts): Container;
    /**
     * Retrieves the value of the specified label.
     */
    label(name: string): Promise<string>;
    /**
     * Retrieves the list of labels passed to container.
     */
    labels(): Promise<Label[]>;
    /**
     * Retrieves the list of paths where a directory is mounted.
     */
    mounts(): Promise<string[]>;
    /**
     * Creates a named sub-pipeline
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name: string, opts?: ContainerPipelineOpts): Container;
    /**
     * The platform this container executes and publishes as.
     */
    platform(): Promise<Platform>;
    /**
     * Publishes this container as a new image to the specified address.
     *
     * Publish returns a fully qualified ref.
     * It can also publish platform variants.
     * @param address Registry's address to publish the image to.
     *
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
     * @param opts.platformVariants Identifiers for other platform specific containers.
     * Used for multi-platform image.
     * @param opts.forcedCompression Force each layer of the published image to use the specified compression algorithm.
     * If this is unset, then if a layer already has a compressed blob in the engine's
     * cache, that will be used (this can result in a mix of compression algorithms for
     * different layers). If this is unset and a layer has no compressed blob in the
     * engine's cache, then it will be compressed using Gzip.
     * @param opts.mediaTypes Use the specified media types for the published image's layers. Defaults to OCI, which
     * is largely compatible with most recent registries, but Docker may be needed for older
     * registries without OCI support.
     */
    publish(address: string, opts?: ContainerPublishOpts): Promise<string>;
    /**
     * Retrieves this container's root filesystem. Mounts are not included.
     */
    rootfs(): Directory;
    /**
     * Return a websocket endpoint that, if connected to, will start the container with a TTY streamed
     * over the websocket.
     *
     * Primarily intended for internal use with the dagger CLI.
     */
    shellEndpoint(): Promise<string>;
    /**
     * The error stream of the last executed command.
     *
     * Will execute default command if none is set, or error if there's no default.
     */
    stderr(): Promise<string>;
    /**
     * The output stream of the last executed command.
     *
     * Will execute default command if none is set, or error if there's no default.
     */
    stdout(): Promise<string>;
    /**
     * Forces evaluation of the pipeline in the engine.
     *
     * It doesn't run the default command if no exec has been set.
     */
    sync(): Promise<Container>;
    /**
     * Retrieves the user to be set for all commands.
     */
    user(): Promise<string>;
    /**
     * Configures default arguments for future commands.
     * @param opts.args Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
     */
    withDefaultArgs(opts?: ContainerWithDefaultArgsOpts): Container;
    /**
     * Retrieves this container plus a directory written at the given path.
     * @param path Location of the written directory (e.g., "/tmp/directory").
     * @param directory Identifier of the directory to write
     * @param opts.exclude Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
     * @param opts.include Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
     * @param opts.owner A user:group to set for the directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withDirectory(path: string, directory: Directory, opts?: ContainerWithDirectoryOpts): Container;
    /**
     * Retrieves this container but with a different command entrypoint.
     * @param args Entrypoint to use for future executions (e.g., ["go", "run"]).
     */
    withEntrypoint(args: string[]): Container;
    /**
     * Retrieves this container plus the given environment variable.
     * @param name The name of the environment variable (e.g., "HOST").
     * @param value The value of the environment variable. (e.g., "localhost").
     * @param opts.expand Replace ${VAR} or $VAR in the value according to the current environment
     * variables defined in the container (e.g., "/opt/bin:$PATH").
     */
    withEnvVariable(name: string, value: string, opts?: ContainerWithEnvVariableOpts): Container;
    /**
     * Retrieves this container after executing the specified command inside it.
     * @param args Command to run instead of the container's default command (e.g., ["run", "main.go"]).
     *
     * If empty, the container's default command is used.
     * @param opts.skipEntrypoint If the container has an entrypoint, ignore it for args rather than using it to wrap them.
     * @param opts.stdin Content to write to the command's standard input before closing (e.g., "Hello world").
     * @param opts.redirectStdout Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
     * @param opts.redirectStderr Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
     * @param opts.experimentalPrivilegedNesting Provides dagger access to the executed command.
     *
     * Do not use this option unless you trust the command being executed.
     * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
     * @param opts.insecureRootCapabilities Execute the command with all root capabilities. This is similar to running a command
     * with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
     * does not provide any security guarantees when using this option. It should only be used
     * when absolutely necessary and only with trusted commands.
     */
    withExec(args: string[], opts?: ContainerWithExecOpts): Container;
    /**
     * Expose a network port.
     *
     * Exposed ports serve two purposes:
     *   - For health checks and introspection, when running services
     *   - For setting the EXPOSE OCI field when publishing the container
     * @param port Port number to expose
     * @param opts.protocol Transport layer network protocol
     * @param opts.description Optional port description
     */
    withExposedPort(port: number, opts?: ContainerWithExposedPortOpts): Container;
    /**
     * Retrieves this container plus the contents of the given file copied to the given path.
     * @param path Location of the copied file (e.g., "/tmp/file.txt").
     * @param source Identifier of the file to copy.
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     * @param opts.owner A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withFile(path: string, source: File, opts?: ContainerWithFileOpts): Container;
    /**
     * Indicate that subsequent operations should be featured more prominently in
     * the UI.
     */
    withFocus(): Container;
    /**
     * Retrieves this container plus the given label.
     * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
     * @param value The value of the label (e.g., "2023-01-01T00:00:00Z").
     */
    withLabel(name: string, value: string): Container;
    /**
     * Retrieves this container plus a cache volume mounted at the given path.
     * @param path Location of the cache directory (e.g., "/cache/node_modules").
     * @param cache Identifier of the cache volume to mount.
     * @param opts.source Identifier of the directory to use as the cache volume's root.
     * @param opts.sharing Sharing mode of the cache volume.
     * @param opts.owner A user:group to set for the mounted cache directory.
     *
     * Note that this changes the ownership of the specified mount along with the
     * initial filesystem provided by source (if any). It does not have any effect
     * if/when the cache has already been created.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedCache(path: string, cache: CacheVolume, opts?: ContainerWithMountedCacheOpts): Container;
    /**
     * Retrieves this container plus a directory mounted at the given path.
     * @param path Location of the mounted directory (e.g., "/mnt/directory").
     * @param source Identifier of the mounted directory.
     * @param opts.owner A user:group to set for the mounted directory and its contents.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedDirectory(path: string, source: Directory, opts?: ContainerWithMountedDirectoryOpts): Container;
    /**
     * Retrieves this container plus a file mounted at the given path.
     * @param path Location of the mounted file (e.g., "/tmp/file.txt").
     * @param source Identifier of the mounted file.
     * @param opts.owner A user or user:group to set for the mounted file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withMountedFile(path: string, source: File, opts?: ContainerWithMountedFileOpts): Container;
    /**
     * Retrieves this container plus a secret mounted into a file at the given path.
     * @param path Location of the secret file (e.g., "/tmp/secret.txt").
     * @param source Identifier of the secret to mount.
     * @param opts.owner A user:group to set for the mounted secret.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     * @param opts.mode Permission given to the mounted secret (e.g., 0600).
     * This option requires an owner to be set to be active.
     *
     * Default: 0400.
     */
    withMountedSecret(path: string, source: Secret, opts?: ContainerWithMountedSecretOpts): Container;
    /**
     * Retrieves this container plus a temporary directory mounted at the given path.
     * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
     */
    withMountedTemp(path: string): Container;
    /**
     * Retrieves this container plus a new file written at the given path.
     * @param path Location of the written file (e.g., "/tmp/file.txt").
     * @param opts.contents Content of the file to write (e.g., "Hello world!").
     * @param opts.permissions Permission given to the written file (e.g., 0600).
     *
     * Default: 0644.
     * @param opts.owner A user:group to set for the file.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withNewFile(path: string, opts?: ContainerWithNewFileOpts): Container;
    /**
     * Retrieves this container with a registry authentication for a given address.
     * @param address Registry's address to bind the authentication to.
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
     * @param username The username of the registry's account (e.g., "Dagger").
     * @param secret The API key, password or token to authenticate to this registry.
     */
    withRegistryAuth(address: string, username: string, secret: Secret): Container;
    /**
     * Initializes this container from this DirectoryID.
     */
    withRootfs(directory: Directory): Container;
    /**
     * Retrieves this container plus an env variable containing the given secret.
     * @param name The name of the secret variable (e.g., "API_SECRET").
     * @param secret The identifier of the secret value.
     */
    withSecretVariable(name: string, secret: Secret): Container;
    /**
     * Establish a runtime dependency on a service.
     *
     * The service will be started automatically when needed and detached when it is
     * no longer needed, executing the default command if none is set.
     *
     * The service will be reachable from the container via the provided hostname alias.
     *
     * The service dependency will also convey to any files or directories produced by the container.
     * @param alias A name that can be used to reach the service from the container
     * @param service Identifier of the service container
     */
    withServiceBinding(alias: string, service: Service): Container;
    /**
     * Retrieves this container plus a socket forwarded to the given Unix socket path.
     * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
     * @param source Identifier of the socket to forward.
     * @param opts.owner A user:group to set for the mounted socket.
     *
     * The user and group can either be an ID (1000:1000) or a name (foo:bar).
     *
     * If the group is omitted, it defaults to the same as the user.
     */
    withUnixSocket(path: string, source: Socket, opts?: ContainerWithUnixSocketOpts): Container;
    /**
     * Retrieves this container with a different command user.
     * @param name The user to set (e.g., "root").
     */
    withUser(name: string): Container;
    /**
     * Retrieves this container with a different working directory.
     * @param path The path to set as the working directory (e.g., "/app").
     */
    withWorkdir(path: string): Container;
    /**
     * Retrieves this container minus the given environment variable.
     * @param name The name of the environment variable (e.g., "HOST").
     */
    withoutEnvVariable(name: string): Container;
    /**
     * Unexpose a previously exposed port.
     * @param port Port number to unexpose
     * @param opts.protocol Port protocol to unexpose
     */
    withoutExposedPort(port: number, opts?: ContainerWithoutExposedPortOpts): Container;
    /**
     * Indicate that subsequent operations should not be featured more prominently
     * in the UI.
     *
     * This is the initial state of all containers.
     */
    withoutFocus(): Container;
    /**
     * Retrieves this container minus the given environment label.
     * @param name The name of the label to remove (e.g., "org.opencontainers.artifact.created").
     */
    withoutLabel(name: string): Container;
    /**
     * Retrieves this container after unmounting everything at the given path.
     * @param path Location of the cache directory (e.g., "/cache/node_modules").
     */
    withoutMount(path: string): Container;
    /**
     * Retrieves this container without the registry authentication of a given address.
     * @param address Registry's address to remove the authentication from.
     * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
     */
    withoutRegistryAuth(address: string): Container;
    /**
     * Retrieves this container with a previously added Unix socket removed.
     * @param path Location of the socket to remove (e.g., "/tmp/socket").
     */
    withoutUnixSocket(path: string): Container;
    /**
     * Retrieves the working directory for all commands.
     */
    workdir(): Promise<string>;
    /**
     * Call the provided function with current Container.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: Container) => Container): Container;
}
/**
 * A directory.
 */
export declare class Directory extends BaseClient {
    private readonly _id?;
    private readonly _export?;
    private readonly _sync?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: DirectoryID, _export?: boolean, _sync?: DirectoryID);
    /**
     * The content-addressed identifier of the directory.
     */
    id(): Promise<DirectoryID>;
    /**
     * Load the directory as a Dagger module
     * @param opts.sourceSubpath An optional subpath of the directory which contains the module's source
     * code.
     *
     * This is needed when the module code is in a subdirectory but requires
     * parent directories to be loaded in order to execute. For example, the
     * module source code may need a go.mod, project.toml, package.json, etc. file
     * from a parent directory.
     *
     * If not set, the module source code is loaded from the root of the
     * directory.
     */
    asModule(opts?: DirectoryAsModuleOpts): Module_;
    /**
     * Gets the difference between this directory and an another directory.
     * @param other Identifier of the directory to compare.
     */
    diff(other: Directory): Directory;
    /**
     * Retrieves a directory at the given path.
     * @param path Location of the directory to retrieve (e.g., "/src").
     */
    directory(path: string): Directory;
    /**
     * Builds a new Docker container from this directory.
     * @param opts.dockerfile Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
     *
     * Defaults: './Dockerfile'.
     * @param opts.platform The platform to build.
     * @param opts.buildArgs Build arguments to use in the build.
     * @param opts.target Target build stage to build.
     * @param opts.secrets Secrets to pass to the build.
     *
     * They will be mounted at /run/secrets/[secret-name].
     */
    dockerBuild(opts?: DirectoryDockerBuildOpts): Container;
    /**
     * Returns a list of files and directories at the given path.
     * @param opts.path Location of the directory to look at (e.g., "/src").
     */
    entries(opts?: DirectoryEntriesOpts): Promise<string[]>;
    /**
     * Writes the contents of the directory to a path on the host.
     * @param path Location of the copied directory (e.g., "logs/").
     */
    export(path: string): Promise<boolean>;
    /**
     * Retrieves a file at the given path.
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    file(path: string): File;
    /**
     * Returns a list of files and directories that matche the given pattern.
     * @param pattern Pattern to match (e.g., "*.md").
     */
    glob(pattern: string): Promise<string[]>;
    /**
     * Creates a named sub-pipeline
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name: string, opts?: DirectoryPipelineOpts): Directory;
    /**
     * Force evaluation in the engine.
     */
    sync(): Promise<Directory>;
    /**
     * Retrieves this directory plus a directory written at the given path.
     * @param path Location of the written directory (e.g., "/src/").
     * @param directory Identifier of the directory to copy.
     * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    withDirectory(path: string, directory: Directory, opts?: DirectoryWithDirectoryOpts): Directory;
    /**
     * Retrieves this directory plus the contents of the given file copied to the given path.
     * @param path Location of the copied file (e.g., "/file.txt").
     * @param source Identifier of the file to copy.
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    withFile(path: string, source: File, opts?: DirectoryWithFileOpts): Directory;
    /**
     * Retrieves this directory plus a new directory created at the given path.
     * @param path Location of the directory created (e.g., "/logs").
     * @param opts.permissions Permission granted to the created directory (e.g., 0777).
     *
     * Default: 0755.
     */
    withNewDirectory(path: string, opts?: DirectoryWithNewDirectoryOpts): Directory;
    /**
     * Retrieves this directory plus a new file written at the given path.
     * @param path Location of the written file (e.g., "/file.txt").
     * @param contents Content of the written file (e.g., "Hello world!").
     * @param opts.permissions Permission given to the copied file (e.g., 0600).
     *
     * Default: 0644.
     */
    withNewFile(path: string, contents: string, opts?: DirectoryWithNewFileOpts): Directory;
    /**
     * Retrieves this directory with all file/dir timestamps set to the given time.
     * @param timestamp Timestamp to set dir/files in.
     *
     * Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    withTimestamps(timestamp: number): Directory;
    /**
     * Retrieves this directory with the directory at the given path removed.
     * @param path Location of the directory to remove (e.g., ".github/").
     */
    withoutDirectory(path: string): Directory;
    /**
     * Retrieves this directory with the file at the given path removed.
     * @param path Location of the file to remove (e.g., "/file.txt").
     */
    withoutFile(path: string): Directory;
    /**
     * Call the provided function with current Directory.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: Directory) => Directory): Directory;
}
/**
 * A simple key value object that represents an environment variable.
 */
export declare class EnvVariable extends BaseClient {
    private readonly _name?;
    private readonly _value?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _name?: string, _value?: string);
    /**
     * The environment variable name.
     */
    name(): Promise<string>;
    /**
     * The environment variable value.
     */
    value(): Promise<string>;
}
/**
 * A definition of a field on a custom object defined in a Module.
 * A field on an object has a static value, as opposed to a function on an
 * object whose value is computed by invoking code (and can accept arguments).
 */
export declare class FieldTypeDef extends BaseClient {
    private readonly _description?;
    private readonly _name?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _description?: string, _name?: string);
    /**
     * A doc string for the field, if any
     */
    description(): Promise<string>;
    /**
     * The name of the field in the object
     */
    name(): Promise<string>;
    /**
     * The type of the field
     */
    typeDef(): TypeDef;
}
/**
 * A file.
 */
export declare class File extends BaseClient {
    private readonly _id?;
    private readonly _contents?;
    private readonly _export?;
    private readonly _size?;
    private readonly _sync?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: FileID, _contents?: string, _export?: boolean, _size?: number, _sync?: FileID);
    /**
     * Retrieves the content-addressed identifier of the file.
     */
    id(): Promise<FileID>;
    /**
     * Retrieves the contents of the file.
     */
    contents(): Promise<string>;
    /**
     * Writes the file to a file path on the host.
     * @param path Location of the written directory (e.g., "output.txt").
     * @param opts.allowParentDirPath If allowParentDirPath is true, the path argument can be a directory path, in which case
     * the file will be created in that directory.
     */
    export(path: string, opts?: FileExportOpts): Promise<boolean>;
    /**
     * Gets the size of the file, in bytes.
     */
    size(): Promise<number>;
    /**
     * Force evaluation in the engine.
     */
    sync(): Promise<File>;
    /**
     * Retrieves this file with its created/modified timestamps set to the given time.
     * @param timestamp Timestamp to set dir/files in.
     *
     * Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    withTimestamps(timestamp: number): File;
    /**
     * Call the provided function with current File.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: File) => File): File;
}
/**
 * Function represents a resolver provided by a Module.
 *
 * A function always evaluates against a parent object and is given a set of
 * named arguments.
 */
export declare class Function_ extends BaseClient {
    private readonly _id?;
    private readonly _description?;
    private readonly _name?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: FunctionID, _description?: string, _name?: string);
    /**
     * The ID of the function
     */
    id(): Promise<FunctionID>;
    /**
     * Arguments accepted by this function, if any
     */
    args(): Promise<FunctionArg[]>;
    /**
     * A doc string for the function, if any
     */
    description(): Promise<string>;
    /**
     * The name of the function
     */
    name(): Promise<string>;
    /**
     * The type returned by this function
     */
    returnType(): TypeDef;
    /**
     * Returns the function with the provided argument
     * @param name The name of the argument
     * @param typeDef The type of the argument
     * @param opts.description A doc string for the argument, if any
     * @param opts.defaultValue A default value to use for this argument if not explicitly set by the caller, if any
     */
    withArg(name: string, typeDef: TypeDef, opts?: FunctionWithArgOpts): Function_;
    /**
     * Returns the function with the doc string
     */
    withDescription(description: string): Function_;
    /**
     * Call the provided function with current Function.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: Function_) => Function_): Function_;
}
/**
 * An argument accepted by a function.
 *
 * This is a specification for an argument at function definition time, not an
 * argument passed at function call time.
 */
export declare class FunctionArg extends BaseClient {
    private readonly _id?;
    private readonly _defaultValue?;
    private readonly _description?;
    private readonly _name?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: FunctionArgID, _defaultValue?: JSON, _description?: string, _name?: string);
    /**
     * The ID of the argument
     */
    id(): Promise<FunctionArgID>;
    /**
     * A default value to use for this argument when not explicitly set by the caller, if any
     */
    defaultValue(): Promise<JSON>;
    /**
     * A doc string for the argument, if any
     */
    description(): Promise<string>;
    /**
     * The name of the argument
     */
    name(): Promise<string>;
    /**
     * The type of the argument
     */
    typeDef(): TypeDef;
}
export declare class FunctionCall extends BaseClient {
    private readonly _name?;
    private readonly _parent?;
    private readonly _parentName?;
    private readonly _returnValue?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _name?: string, _parent?: JSON, _parentName?: string, _returnValue?: Void);
    /**
     * The argument values the function is being invoked with.
     */
    inputArgs(): Promise<FunctionCallArgValue[]>;
    /**
     * The name of the function being called.
     */
    name(): Promise<string>;
    /**
     * The value of the parent object of the function being called.
     * If the function is "top-level" to the module, this is always an empty object.
     */
    parent(): Promise<JSON>;
    /**
     * The name of the parent object of the function being called.
     * If the function is "top-level" to the module, this is the name of the module.
     */
    parentName(): Promise<string>;
    /**
     * Set the return value of the function call to the provided value.
     * The value should be a string of the JSON serialization of the return value.
     */
    returnValue(value: JSON): Promise<Void>;
}
export declare class FunctionCallArgValue extends BaseClient {
    private readonly _name?;
    private readonly _value?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _name?: string, _value?: JSON);
    /**
     * The name of the argument.
     */
    name(): Promise<string>;
    /**
     * The value of the argument represented as a string of the JSON serialization.
     */
    value(): Promise<JSON>;
}
export declare class GeneratedCode extends BaseClient {
    private readonly _id?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: GeneratedCodeID);
    id(): Promise<GeneratedCodeID>;
    /**
     * The directory containing the generated code
     */
    code(): Directory;
    /**
     * List of paths to mark generated in version control (i.e. .gitattributes)
     */
    vcsGeneratedPaths(): Promise<string[]>;
    /**
     * List of paths to ignore in version control (i.e. .gitignore)
     */
    vcsIgnoredPaths(): Promise<string[]>;
    /**
     * Set the list of paths to mark generated in version control
     */
    withVCSGeneratedPaths(paths: string[]): GeneratedCode;
    /**
     * Set the list of paths to ignore in version control
     */
    withVCSIgnoredPaths(paths: string[]): GeneratedCode;
    /**
     * Call the provided function with current GeneratedCode.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: GeneratedCode) => GeneratedCode): GeneratedCode;
}
/**
 * A git ref (tag, branch or commit).
 */
export declare class GitRef extends BaseClient {
    private readonly _commit?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _commit?: string);
    /**
     * The resolved commit id at this ref.
     */
    commit(): Promise<string>;
    /**
     * The filesystem tree at this ref.
     */
    tree(opts?: GitRefTreeOpts): Directory;
}
/**
 * A git repository.
 */
export declare class GitRepository extends BaseClient {
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    });
    /**
     * Returns details on one branch.
     * @param name Branch's name (e.g., "main").
     */
    branch(name: string): GitRef;
    /**
     * Returns details on one commit.
     * @param id Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
     */
    commit(id: string): GitRef;
    /**
     * Returns details on one tag.
     * @param name Tag's name (e.g., "v0.3.9").
     */
    tag(name: string): GitRef;
}
/**
 * Information about the host execution environment.
 */
export declare class Host extends BaseClient {
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    });
    /**
     * Accesses a directory on the host.
     * @param path Location of the directory to access (e.g., ".").
     * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
     * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
     */
    directory(path: string, opts?: HostDirectoryOpts): Directory;
    /**
     * Accesses a file on the host.
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    file(path: string): File;
    /**
     * Creates a service that forwards traffic to a specified address via the host.
     * @param ports Ports to expose via the service, forwarding through the host network.
     *
     * If a port's frontend is unspecified or 0, it defaults to the same as the
     * backend port.
     *
     * An empty set of ports is not valid; an error will be returned.
     * @param opts.host Upstream host to forward traffic to.
     */
    service(ports: PortForward[], opts?: HostServiceOpts): Service;
    /**
     * Sets a secret given a user-defined name and the file path on the host, and returns the secret.
     * The file is limited to a size of 512000 bytes.
     * @param name The user defined name for this secret.
     * @param path Location of the file to set as a secret.
     */
    setSecretFile(name: string, path: string): Secret;
    /**
     * Creates a tunnel that forwards traffic from the host to a service.
     * @param service Service to send traffic from the tunnel.
     * @param opts.native Map each service port to the same port on the host, as if the service were
     * running natively.
     *
     * Note: enabling may result in port conflicts.
     * @param opts.ports Configure explicit port forwarding rules for the tunnel.
     *
     * If a port's frontend is unspecified or 0, a random port will be chosen by
     * the host.
     *
     * If no ports are given, all of the service's ports are forwarded. If native
     * is true, each port maps to the same port on the host. If native is false,
     * each port maps to a random port chosen by the host.
     *
     * If ports are given and native is true, the ports are additive.
     */
    tunnel(service: Service, opts?: HostTunnelOpts): Service;
    /**
     * Accesses a Unix socket on the host.
     * @param path Location of the Unix socket (e.g., "/var/run/docker.sock").
     */
    unixSocket(path: string): Socket;
}
/**
 * A simple key value object that represents a label.
 */
export declare class Label extends BaseClient {
    private readonly _name?;
    private readonly _value?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _name?: string, _value?: string);
    /**
     * The label name.
     */
    name(): Promise<string>;
    /**
     * The label value.
     */
    value(): Promise<string>;
}
/**
 * A definition of a list type in a Module.
 */
export declare class ListTypeDef extends BaseClient {
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    });
    /**
     * The type of the elements in the list
     */
    elementTypeDef(): TypeDef;
}
export declare class Module_ extends BaseClient {
    private readonly _id?;
    private readonly _description?;
    private readonly _name?;
    private readonly _sdk?;
    private readonly _serve?;
    private readonly _sourceDirectorySubPath?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: ModuleID, _description?: string, _name?: string, _sdk?: string, _serve?: Void, _sourceDirectorySubPath?: string);
    /**
     * The ID of the module
     */
    id(): Promise<ModuleID>;
    /**
     * Modules used by this module
     */
    dependencies(): Promise<Module_[]>;
    /**
     * The dependencies as configured by the module
     */
    dependencyConfig(): Promise<string[]>;
    /**
     * The doc string of the module, if any
     */
    description(): Promise<string>;
    /**
     * The code generated by the SDK's runtime
     */
    generatedCode(): GeneratedCode;
    /**
     * The name of the module
     */
    name(): Promise<string>;
    /**
     * Objects served by this module
     */
    objects(): Promise<TypeDef[]>;
    /**
     * The SDK used by this module. Either a name of a builtin SDK or a module ref pointing to the SDK's implementation.
     */
    sdk(): Promise<string>;
    /**
     * Serve a module's API in the current session.
     *     Note: this can only be called once per session.
     *     In the future, it could return a stream or service to remove the side effect.
     */
    serve(): Promise<Void>;
    /**
     * The directory containing the module's source code
     */
    sourceDirectory(): Directory;
    /**
     * The module's subpath within the source directory
     */
    sourceDirectorySubPath(): Promise<string>;
    /**
     * This module plus the given Object type and associated functions
     */
    withObject(object: TypeDef): Module_;
    /**
     * Call the provided function with current Module.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: Module_) => Module_): Module_;
}
/**
 * Static configuration for a module (e.g. parsed contents of dagger.json)
 */
export declare class ModuleConfig extends BaseClient {
    private readonly _name?;
    private readonly _root?;
    private readonly _sdk?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _name?: string, _root?: string, _sdk?: string);
    /**
     * Modules that this module depends on.
     */
    dependencies(): Promise<string[]>;
    /**
     * Exclude these file globs when loading the module root.
     */
    exclude(): Promise<string[]>;
    /**
     * Include only these file globs when loading the module root.
     */
    include(): Promise<string[]>;
    /**
     * The name of the module.
     */
    name(): Promise<string>;
    /**
     * The root directory of the module's project, which may be above the module source code.
     */
    root(): Promise<string>;
    /**
     * Either the name of a built-in SDK ('go', 'python', etc.) OR a module reference pointing to the SDK's module implementation.
     */
    sdk(): Promise<string>;
}
/**
 * A definition of a custom object defined in a Module.
 */
export declare class ObjectTypeDef extends BaseClient {
    private readonly _description?;
    private readonly _name?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _description?: string, _name?: string);
    /**
     * The doc string for the object, if any
     */
    description(): Promise<string>;
    /**
     * Static fields defined on this object, if any
     */
    fields(): Promise<FieldTypeDef[]>;
    /**
     * Functions defined on this object, if any
     */
    functions(): Promise<Function_[]>;
    /**
     * The name of the object
     */
    name(): Promise<string>;
}
/**
 * A port exposed by a container.
 */
export declare class Port extends BaseClient {
    private readonly _description?;
    private readonly _port?;
    private readonly _protocol?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _description?: string, _port?: number, _protocol?: NetworkProtocol);
    /**
     * The port description.
     */
    description(): Promise<string>;
    /**
     * The port number.
     */
    port(): Promise<number>;
    /**
     * The transport layer network protocol.
     */
    protocol(): Promise<NetworkProtocol>;
}
export declare class Client extends BaseClient {
    private readonly _checkVersionCompatibility?;
    private readonly _defaultPlatform?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _checkVersionCompatibility?: boolean, _defaultPlatform?: Platform);
    /**
     * Constructs a cache volume for a given cache key.
     * @param key A string identifier to target this cache volume (e.g., "modules-cache").
     */
    cacheVolume(key: string): CacheVolume;
    /**
     * Checks if the current Dagger Engine is compatible with an SDK's required version.
     * @param version The SDK's required version.
     */
    checkVersionCompatibility(version: string): Promise<boolean>;
    /**
     * Creates a scratch container or loads one by ID.
     *
     * Optional platform argument initializes new containers to execute and publish
     * as that platform. Platform defaults to that of the builder's host.
     */
    container(opts?: ClientContainerOpts): Container;
    /**
     * The FunctionCall context that the SDK caller is currently executing in.
     * If the caller is not currently executing in a function, this will return
     * an error.
     */
    currentFunctionCall(): FunctionCall;
    /**
     * The module currently being served in the session, if any.
     */
    currentModule(): Module_;
    /**
     * The default platform of the builder.
     */
    defaultPlatform(): Promise<Platform>;
    /**
     * Creates an empty directory or loads one by ID.
     */
    directory(opts?: ClientDirectoryOpts): Directory;
    /**
     * Loads a file by ID.
     * @deprecated Use loadFileFromID instead.
     */
    file(id: FileID): File;
    /**
     * Create a function.
     */
    function_(name: string, returnType: TypeDef): Function_;
    /**
     * Create a code generation result, given a directory containing the generated
     * code.
     */
    generatedCode(code: Directory): GeneratedCode;
    /**
     * Queries a git repository.
     * @param url Url of the git repository.
     * Can be formatted as https://{host}/{owner}/{repo}, git@{host}:{owner}/{repo}
     * Suffix ".git" is optional.
     * @param opts.keepGitDir Set to true to keep .git directory.
     * @param opts.sshKnownHosts Set SSH known hosts
     * @param opts.sshAuthSocket Set SSH auth socket
     * @param opts.experimentalServiceHost A service which must be started before the repo is fetched.
     */
    git(url: string, opts?: ClientGitOpts): GitRepository;
    /**
     * Queries the host environment.
     */
    host(): Host;
    /**
     * Returns a file containing an http remote url content.
     * @param url HTTP url to get the content from (e.g., "https://docs.dagger.io").
     * @param opts.experimentalServiceHost A service which must be started before the URL is fetched.
     */
    http(url: string, opts?: ClientHttpOpts): File;
    /**
     * Load a CacheVolume from its ID.
     */
    loadCacheVolumeFromID(id: CacheVolumeID): CacheVolume;
    /**
     * Loads a container from an ID.
     */
    loadContainerFromID(id: ContainerID): Container;
    /**
     * Load a Directory from its ID.
     */
    loadDirectoryFromID(id: DirectoryID): Directory;
    /**
     * Load a File from its ID.
     */
    loadFileFromID(id: FileID): File;
    /**
     * Load a function argument by ID.
     */
    loadFunctionArgFromID(id: FunctionArgID): FunctionArg;
    /**
     * Load a function by ID.
     */
    loadFunctionFromID(id: FunctionID): Function_;
    /**
     * Load a GeneratedCode by ID.
     */
    loadGeneratedCodeFromID(id: GeneratedCodeID): GeneratedCode;
    /**
     * Load a module by ID.
     */
    loadModuleFromID(id: ModuleID): Module_;
    /**
     * Load a Secret from its ID.
     */
    loadSecretFromID(id: SecretID): Secret;
    /**
     * Loads a service from ID.
     */
    loadServiceFromID(id: ServiceID): Service;
    /**
     * Load a Socket from its ID.
     */
    loadSocketFromID(id: SocketID): Socket;
    /**
     * Load a TypeDef by ID.
     */
    loadTypeDefFromID(id: TypeDefID): TypeDef;
    /**
     * Create a new module.
     */
    module_(): Module_;
    /**
     * Load the static configuration for a module from the given source directory and optional subpath.
     */
    moduleConfig(sourceDirectory: Directory, opts?: ClientModuleConfigOpts): ModuleConfig;
    /**
     * Creates a named sub-pipeline.
     * @param name Pipeline name.
     * @param opts.description Pipeline description.
     * @param opts.labels Pipeline labels.
     */
    pipeline(name: string, opts?: ClientPipelineOpts): Client;
    /**
     * Loads a secret from its ID.
     * @deprecated Use loadSecretFromID instead
     */
    secret(id: SecretID): Secret;
    /**
     * Sets a secret given a user defined name to its plaintext and returns the secret.
     * The plaintext value is limited to a size of 128000 bytes.
     * @param name The user defined name for this secret
     * @param plaintext The plaintext of the secret
     */
    setSecret(name: string, plaintext: string): Secret;
    /**
     * Loads a socket by its ID.
     * @deprecated Use loadSocketFromID instead.
     */
    socket(opts?: ClientSocketOpts): Socket;
    /**
     * Create a new TypeDef.
     */
    typeDef(): TypeDef;
    /**
     * Call the provided function with current Client.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: Client) => Client): Client;
}
/**
 * A reference to a secret value, which can be handled more safely than the value itself.
 */
export declare class Secret extends BaseClient {
    private readonly _id?;
    private readonly _plaintext?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: SecretID, _plaintext?: string);
    /**
     * The identifier for this secret.
     */
    id(): Promise<SecretID>;
    /**
     * The value of this secret.
     */
    plaintext(): Promise<string>;
}
export declare class Service extends BaseClient {
    private readonly _id?;
    private readonly _endpoint?;
    private readonly _hostname?;
    private readonly _start?;
    private readonly _stop?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: ServiceID, _endpoint?: string, _hostname?: string, _start?: ServiceID, _stop?: ServiceID);
    /**
     * A unique identifier for this service.
     */
    id(): Promise<ServiceID>;
    /**
     * Retrieves an endpoint that clients can use to reach this container.
     *
     * If no port is specified, the first exposed port is used. If none exist an error is returned.
     *
     * If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
     * @param opts.port The exposed port number for the endpoint
     * @param opts.scheme Return a URL with the given scheme, eg. http for http://
     */
    endpoint(opts?: ServiceEndpointOpts): Promise<string>;
    /**
     * Retrieves a hostname which can be used by clients to reach this container.
     */
    hostname(): Promise<string>;
    /**
     * Retrieves the list of ports provided by the service.
     */
    ports(): Promise<Port[]>;
    /**
     * Start the service and wait for its health checks to succeed.
     *
     * Services bound to a Container do not need to be manually started.
     */
    start(): Promise<Service>;
    /**
     * Stop the service.
     */
    stop(): Promise<Service>;
}
export declare class Socket extends BaseClient {
    private readonly _id?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: SocketID);
    /**
     * The content-addressed identifier of the socket.
     */
    id(): Promise<SocketID>;
}
/**
 * A definition of a parameter or return type in a Module.
 */
export declare class TypeDef extends BaseClient {
    private readonly _id?;
    private readonly _kind?;
    private readonly _optional?;
    /**
     * Constructor is used for internal usage only, do not create object from it.
     */
    constructor(parent?: {
        queryTree?: QueryTree[];
        host?: string;
        sessionToken?: string;
    }, _id?: TypeDefID, _kind?: TypeDefKind, _optional?: boolean);
    id(): Promise<TypeDefID>;
    /**
     * If kind is LIST, the list-specific type definition.
     * If kind is not LIST, this will be null.
     */
    asList(): ListTypeDef;
    /**
     * If kind is OBJECT, the object-specific type definition.
     * If kind is not OBJECT, this will be null.
     */
    asObject(): ObjectTypeDef;
    /**
     * The kind of type this is (e.g. primitive, list, object)
     */
    kind(): Promise<TypeDefKind>;
    /**
     * Whether this type can be set to null. Defaults to false.
     */
    optional(): Promise<boolean>;
    /**
     * Adds a static field for an Object TypeDef, failing if the type is not an object.
     * @param name The name of the field in the object
     * @param typeDef The type of the field
     * @param opts.description A doc string for the field, if any
     */
    withField(name: string, typeDef: TypeDef, opts?: TypeDefWithFieldOpts): TypeDef;
    /**
     * Adds a function for an Object TypeDef, failing if the type is not an object.
     */
    withFunction(function_: Function_): TypeDef;
    /**
     * Sets the kind of the type.
     */
    withKind(kind: TypeDefKind): TypeDef;
    /**
     * Returns a TypeDef of kind List with the provided type for its elements.
     */
    withListOf(elementType: TypeDef): TypeDef;
    /**
     * Returns a TypeDef of kind Object with the provided name.
     *
     * Note that an object's fields and functions may be omitted if the intent is
     * only to refer to an object. This is how functions are able to return their
     * own object, or any other circular reference.
     */
    withObject(name: string, opts?: TypeDefWithObjectOpts): TypeDef;
    /**
     * Sets whether this type can be set to null.
     */
    withOptional(optional: boolean): TypeDef;
    /**
     * Call the provided function with current TypeDef.
     *
     * This is useful for reusability and readability by not breaking the calling chain.
     */
    with(arg: (param: TypeDef) => TypeDef): TypeDef;
}
export {};
//# sourceMappingURL=client.gen.d.ts.map